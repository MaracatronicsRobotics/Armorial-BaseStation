// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssl_simulation_config.proto

#ifndef PROTOBUF_INCLUDED_ssl_5fsimulation_5fconfig_2eproto
#define PROTOBUF_INCLUDED_ssl_5fsimulation_5fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "ssl_gc_common.pb.h"
#include "ssl_vision_geometry.pb.h"
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_ssl_5fsimulation_5fconfig_2eproto 

namespace protobuf_ssl_5fsimulation_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_ssl_5fsimulation_5fconfig_2eproto
class RealismConfig;
class RealismConfigDefaultTypeInternal;
extern RealismConfigDefaultTypeInternal _RealismConfig_default_instance_;
class RobotLimits;
class RobotLimitsDefaultTypeInternal;
extern RobotLimitsDefaultTypeInternal _RobotLimits_default_instance_;
class RobotSpecs;
class RobotSpecsDefaultTypeInternal;
extern RobotSpecsDefaultTypeInternal _RobotSpecs_default_instance_;
class RobotWheelAngles;
class RobotWheelAnglesDefaultTypeInternal;
extern RobotWheelAnglesDefaultTypeInternal _RobotWheelAngles_default_instance_;
class SimulatorConfig;
class SimulatorConfigDefaultTypeInternal;
extern SimulatorConfigDefaultTypeInternal _SimulatorConfig_default_instance_;
namespace google {
namespace protobuf {
template<> ::RealismConfig* Arena::CreateMaybeMessage<::RealismConfig>(Arena*);
template<> ::RobotLimits* Arena::CreateMaybeMessage<::RobotLimits>(Arena*);
template<> ::RobotSpecs* Arena::CreateMaybeMessage<::RobotSpecs>(Arena*);
template<> ::RobotWheelAngles* Arena::CreateMaybeMessage<::RobotWheelAngles>(Arena*);
template<> ::SimulatorConfig* Arena::CreateMaybeMessage<::SimulatorConfig>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class RobotLimits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotLimits) */ {
 public:
  RobotLimits();
  virtual ~RobotLimits();

  RobotLimits(const RobotLimits& from);

  inline RobotLimits& operator=(const RobotLimits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotLimits(RobotLimits&& from) noexcept
    : RobotLimits() {
    *this = ::std::move(from);
  }

  inline RobotLimits& operator=(RobotLimits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotLimits* internal_default_instance() {
    return reinterpret_cast<const RobotLimits*>(
               &_RobotLimits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RobotLimits* other);
  friend void swap(RobotLimits& a, RobotLimits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotLimits* New() const final {
    return CreateMaybeMessage<RobotLimits>(NULL);
  }

  RobotLimits* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotLimits>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotLimits& from);
  void MergeFrom(const RobotLimits& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotLimits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float acc_speedup_absolute_max = 1;
  bool has_acc_speedup_absolute_max() const;
  void clear_acc_speedup_absolute_max();
  static const int kAccSpeedupAbsoluteMaxFieldNumber = 1;
  float acc_speedup_absolute_max() const;
  void set_acc_speedup_absolute_max(float value);

  // optional float acc_speedup_angular_max = 2;
  bool has_acc_speedup_angular_max() const;
  void clear_acc_speedup_angular_max();
  static const int kAccSpeedupAngularMaxFieldNumber = 2;
  float acc_speedup_angular_max() const;
  void set_acc_speedup_angular_max(float value);

  // optional float acc_brake_absolute_max = 3;
  bool has_acc_brake_absolute_max() const;
  void clear_acc_brake_absolute_max();
  static const int kAccBrakeAbsoluteMaxFieldNumber = 3;
  float acc_brake_absolute_max() const;
  void set_acc_brake_absolute_max(float value);

  // optional float acc_brake_angular_max = 4;
  bool has_acc_brake_angular_max() const;
  void clear_acc_brake_angular_max();
  static const int kAccBrakeAngularMaxFieldNumber = 4;
  float acc_brake_angular_max() const;
  void set_acc_brake_angular_max(float value);

  // optional float vel_absolute_max = 5;
  bool has_vel_absolute_max() const;
  void clear_vel_absolute_max();
  static const int kVelAbsoluteMaxFieldNumber = 5;
  float vel_absolute_max() const;
  void set_vel_absolute_max(float value);

  // optional float vel_angular_max = 6;
  bool has_vel_angular_max() const;
  void clear_vel_angular_max();
  static const int kVelAngularMaxFieldNumber = 6;
  float vel_angular_max() const;
  void set_vel_angular_max(float value);

  // @@protoc_insertion_point(class_scope:RobotLimits)
 private:
  void set_has_acc_speedup_absolute_max();
  void clear_has_acc_speedup_absolute_max();
  void set_has_acc_speedup_angular_max();
  void clear_has_acc_speedup_angular_max();
  void set_has_acc_brake_absolute_max();
  void clear_has_acc_brake_absolute_max();
  void set_has_acc_brake_angular_max();
  void clear_has_acc_brake_angular_max();
  void set_has_vel_absolute_max();
  void clear_has_vel_absolute_max();
  void set_has_vel_angular_max();
  void clear_has_vel_angular_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float acc_speedup_absolute_max_;
  float acc_speedup_angular_max_;
  float acc_brake_absolute_max_;
  float acc_brake_angular_max_;
  float vel_absolute_max_;
  float vel_angular_max_;
  friend struct ::protobuf_ssl_5fsimulation_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotWheelAngles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotWheelAngles) */ {
 public:
  RobotWheelAngles();
  virtual ~RobotWheelAngles();

  RobotWheelAngles(const RobotWheelAngles& from);

  inline RobotWheelAngles& operator=(const RobotWheelAngles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotWheelAngles(RobotWheelAngles&& from) noexcept
    : RobotWheelAngles() {
    *this = ::std::move(from);
  }

  inline RobotWheelAngles& operator=(RobotWheelAngles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotWheelAngles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotWheelAngles* internal_default_instance() {
    return reinterpret_cast<const RobotWheelAngles*>(
               &_RobotWheelAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RobotWheelAngles* other);
  friend void swap(RobotWheelAngles& a, RobotWheelAngles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotWheelAngles* New() const final {
    return CreateMaybeMessage<RobotWheelAngles>(NULL);
  }

  RobotWheelAngles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotWheelAngles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotWheelAngles& from);
  void MergeFrom(const RobotWheelAngles& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotWheelAngles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float front_right = 1;
  bool has_front_right() const;
  void clear_front_right();
  static const int kFrontRightFieldNumber = 1;
  float front_right() const;
  void set_front_right(float value);

  // required float back_right = 2;
  bool has_back_right() const;
  void clear_back_right();
  static const int kBackRightFieldNumber = 2;
  float back_right() const;
  void set_back_right(float value);

  // required float back_left = 3;
  bool has_back_left() const;
  void clear_back_left();
  static const int kBackLeftFieldNumber = 3;
  float back_left() const;
  void set_back_left(float value);

  // required float front_left = 4;
  bool has_front_left() const;
  void clear_front_left();
  static const int kFrontLeftFieldNumber = 4;
  float front_left() const;
  void set_front_left(float value);

  // @@protoc_insertion_point(class_scope:RobotWheelAngles)
 private:
  void set_has_front_right();
  void clear_has_front_right();
  void set_has_back_right();
  void clear_has_back_right();
  void set_has_back_left();
  void clear_has_back_left();
  void set_has_front_left();
  void clear_has_front_left();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float front_right_;
  float back_right_;
  float back_left_;
  float front_left_;
  friend struct ::protobuf_ssl_5fsimulation_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotSpecs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotSpecs) */ {
 public:
  RobotSpecs();
  virtual ~RobotSpecs();

  RobotSpecs(const RobotSpecs& from);

  inline RobotSpecs& operator=(const RobotSpecs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotSpecs(RobotSpecs&& from) noexcept
    : RobotSpecs() {
    *this = ::std::move(from);
  }

  inline RobotSpecs& operator=(RobotSpecs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotSpecs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotSpecs* internal_default_instance() {
    return reinterpret_cast<const RobotSpecs*>(
               &_RobotSpecs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RobotSpecs* other);
  friend void swap(RobotSpecs& a, RobotSpecs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotSpecs* New() const final {
    return CreateMaybeMessage<RobotSpecs>(NULL);
  }

  RobotSpecs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotSpecs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotSpecs& from);
  void MergeFrom(const RobotSpecs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotSpecs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any custom = 14;
  int custom_size() const;
  void clear_custom();
  static const int kCustomFieldNumber = 14;
  ::google::protobuf::Any* mutable_custom(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_custom();
  const ::google::protobuf::Any& custom(int index) const;
  ::google::protobuf::Any* add_custom();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      custom() const;

  // required .RobotId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::RobotId& _internal_id() const;
  public:
  const ::RobotId& id() const;
  ::RobotId* release_id();
  ::RobotId* mutable_id();
  void set_allocated_id(::RobotId* id);

  // optional .RobotLimits limits = 10;
  bool has_limits() const;
  void clear_limits();
  static const int kLimitsFieldNumber = 10;
  private:
  const ::RobotLimits& _internal_limits() const;
  public:
  const ::RobotLimits& limits() const;
  ::RobotLimits* release_limits();
  ::RobotLimits* mutable_limits();
  void set_allocated_limits(::RobotLimits* limits);

  // optional .RobotWheelAngles wheel_angles = 13;
  bool has_wheel_angles() const;
  void clear_wheel_angles();
  static const int kWheelAnglesFieldNumber = 13;
  private:
  const ::RobotWheelAngles& _internal_wheel_angles() const;
  public:
  const ::RobotWheelAngles& wheel_angles() const;
  ::RobotWheelAngles* release_wheel_angles();
  ::RobotWheelAngles* mutable_wheel_angles();
  void set_allocated_wheel_angles(::RobotWheelAngles* wheel_angles);

  // optional float mass = 4;
  bool has_mass() const;
  void clear_mass();
  static const int kMassFieldNumber = 4;
  float mass() const;
  void set_mass(float value);

  // optional float max_linear_kick_speed = 7;
  bool has_max_linear_kick_speed() const;
  void clear_max_linear_kick_speed();
  static const int kMaxLinearKickSpeedFieldNumber = 7;
  float max_linear_kick_speed() const;
  void set_max_linear_kick_speed(float value);

  // optional float max_chip_kick_speed = 8;
  bool has_max_chip_kick_speed() const;
  void clear_max_chip_kick_speed();
  static const int kMaxChipKickSpeedFieldNumber = 8;
  float max_chip_kick_speed() const;
  void set_max_chip_kick_speed(float value);

  // optional float center_to_dribbler = 9;
  bool has_center_to_dribbler() const;
  void clear_center_to_dribbler();
  static const int kCenterToDribblerFieldNumber = 9;
  float center_to_dribbler() const;
  void set_center_to_dribbler(float value);

  // optional float radius = 2 [default = 0.09];
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  float radius() const;
  void set_radius(float value);

  // optional float height = 3 [default = 0.15];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:RobotSpecs)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_radius();
  void clear_has_radius();
  void set_has_height();
  void clear_has_height();
  void set_has_mass();
  void clear_has_mass();
  void set_has_max_linear_kick_speed();
  void clear_has_max_linear_kick_speed();
  void set_has_max_chip_kick_speed();
  void clear_has_max_chip_kick_speed();
  void set_has_center_to_dribbler();
  void clear_has_center_to_dribbler();
  void set_has_limits();
  void clear_has_limits();
  void set_has_wheel_angles();
  void clear_has_wheel_angles();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > custom_;
  ::RobotId* id_;
  ::RobotLimits* limits_;
  ::RobotWheelAngles* wheel_angles_;
  float mass_;
  float max_linear_kick_speed_;
  float max_chip_kick_speed_;
  float center_to_dribbler_;
  float radius_;
  float height_;
  friend struct ::protobuf_ssl_5fsimulation_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RealismConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RealismConfig) */ {
 public:
  RealismConfig();
  virtual ~RealismConfig();

  RealismConfig(const RealismConfig& from);

  inline RealismConfig& operator=(const RealismConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RealismConfig(RealismConfig&& from) noexcept
    : RealismConfig() {
    *this = ::std::move(from);
  }

  inline RealismConfig& operator=(RealismConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RealismConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RealismConfig* internal_default_instance() {
    return reinterpret_cast<const RealismConfig*>(
               &_RealismConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RealismConfig* other);
  friend void swap(RealismConfig& a, RealismConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RealismConfig* New() const final {
    return CreateMaybeMessage<RealismConfig>(NULL);
  }

  RealismConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RealismConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RealismConfig& from);
  void MergeFrom(const RealismConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RealismConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any custom = 1;
  int custom_size() const;
  void clear_custom();
  static const int kCustomFieldNumber = 1;
  ::google::protobuf::Any* mutable_custom(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_custom();
  const ::google::protobuf::Any& custom(int index) const;
  ::google::protobuf::Any* add_custom();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      custom() const;

  // @@protoc_insertion_point(class_scope:RealismConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > custom_;
  friend struct ::protobuf_ssl_5fsimulation_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimulatorConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SimulatorConfig) */ {
 public:
  SimulatorConfig();
  virtual ~SimulatorConfig();

  SimulatorConfig(const SimulatorConfig& from);

  inline SimulatorConfig& operator=(const SimulatorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimulatorConfig(SimulatorConfig&& from) noexcept
    : SimulatorConfig() {
    *this = ::std::move(from);
  }

  inline SimulatorConfig& operator=(SimulatorConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimulatorConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatorConfig* internal_default_instance() {
    return reinterpret_cast<const SimulatorConfig*>(
               &_SimulatorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SimulatorConfig* other);
  friend void swap(SimulatorConfig& a, SimulatorConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimulatorConfig* New() const final {
    return CreateMaybeMessage<SimulatorConfig>(NULL);
  }

  SimulatorConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SimulatorConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SimulatorConfig& from);
  void MergeFrom(const SimulatorConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulatorConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RobotSpecs robot_specs = 2;
  int robot_specs_size() const;
  void clear_robot_specs();
  static const int kRobotSpecsFieldNumber = 2;
  ::RobotSpecs* mutable_robot_specs(int index);
  ::google::protobuf::RepeatedPtrField< ::RobotSpecs >*
      mutable_robot_specs();
  const ::RobotSpecs& robot_specs(int index) const;
  ::RobotSpecs* add_robot_specs();
  const ::google::protobuf::RepeatedPtrField< ::RobotSpecs >&
      robot_specs() const;

  // optional .SSL_GeometryData geometry = 1;
  bool has_geometry() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  private:
  const ::SSL_GeometryData& _internal_geometry() const;
  public:
  const ::SSL_GeometryData& geometry() const;
  ::SSL_GeometryData* release_geometry();
  ::SSL_GeometryData* mutable_geometry();
  void set_allocated_geometry(::SSL_GeometryData* geometry);

  // optional .RealismConfig realism_config = 3;
  bool has_realism_config() const;
  void clear_realism_config();
  static const int kRealismConfigFieldNumber = 3;
  private:
  const ::RealismConfig& _internal_realism_config() const;
  public:
  const ::RealismConfig& realism_config() const;
  ::RealismConfig* release_realism_config();
  ::RealismConfig* mutable_realism_config();
  void set_allocated_realism_config(::RealismConfig* realism_config);

  // optional uint32 vision_port = 4;
  bool has_vision_port() const;
  void clear_vision_port();
  static const int kVisionPortFieldNumber = 4;
  ::google::protobuf::uint32 vision_port() const;
  void set_vision_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SimulatorConfig)
 private:
  void set_has_geometry();
  void clear_has_geometry();
  void set_has_realism_config();
  void clear_has_realism_config();
  void set_has_vision_port();
  void clear_has_vision_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RobotSpecs > robot_specs_;
  ::SSL_GeometryData* geometry_;
  ::RealismConfig* realism_config_;
  ::google::protobuf::uint32 vision_port_;
  friend struct ::protobuf_ssl_5fsimulation_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotLimits

// optional float acc_speedup_absolute_max = 1;
inline bool RobotLimits::has_acc_speedup_absolute_max() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotLimits::set_has_acc_speedup_absolute_max() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotLimits::clear_has_acc_speedup_absolute_max() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotLimits::clear_acc_speedup_absolute_max() {
  acc_speedup_absolute_max_ = 0;
  clear_has_acc_speedup_absolute_max();
}
inline float RobotLimits::acc_speedup_absolute_max() const {
  // @@protoc_insertion_point(field_get:RobotLimits.acc_speedup_absolute_max)
  return acc_speedup_absolute_max_;
}
inline void RobotLimits::set_acc_speedup_absolute_max(float value) {
  set_has_acc_speedup_absolute_max();
  acc_speedup_absolute_max_ = value;
  // @@protoc_insertion_point(field_set:RobotLimits.acc_speedup_absolute_max)
}

// optional float acc_speedup_angular_max = 2;
inline bool RobotLimits::has_acc_speedup_angular_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotLimits::set_has_acc_speedup_angular_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotLimits::clear_has_acc_speedup_angular_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotLimits::clear_acc_speedup_angular_max() {
  acc_speedup_angular_max_ = 0;
  clear_has_acc_speedup_angular_max();
}
inline float RobotLimits::acc_speedup_angular_max() const {
  // @@protoc_insertion_point(field_get:RobotLimits.acc_speedup_angular_max)
  return acc_speedup_angular_max_;
}
inline void RobotLimits::set_acc_speedup_angular_max(float value) {
  set_has_acc_speedup_angular_max();
  acc_speedup_angular_max_ = value;
  // @@protoc_insertion_point(field_set:RobotLimits.acc_speedup_angular_max)
}

// optional float acc_brake_absolute_max = 3;
inline bool RobotLimits::has_acc_brake_absolute_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotLimits::set_has_acc_brake_absolute_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotLimits::clear_has_acc_brake_absolute_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotLimits::clear_acc_brake_absolute_max() {
  acc_brake_absolute_max_ = 0;
  clear_has_acc_brake_absolute_max();
}
inline float RobotLimits::acc_brake_absolute_max() const {
  // @@protoc_insertion_point(field_get:RobotLimits.acc_brake_absolute_max)
  return acc_brake_absolute_max_;
}
inline void RobotLimits::set_acc_brake_absolute_max(float value) {
  set_has_acc_brake_absolute_max();
  acc_brake_absolute_max_ = value;
  // @@protoc_insertion_point(field_set:RobotLimits.acc_brake_absolute_max)
}

// optional float acc_brake_angular_max = 4;
inline bool RobotLimits::has_acc_brake_angular_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotLimits::set_has_acc_brake_angular_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotLimits::clear_has_acc_brake_angular_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotLimits::clear_acc_brake_angular_max() {
  acc_brake_angular_max_ = 0;
  clear_has_acc_brake_angular_max();
}
inline float RobotLimits::acc_brake_angular_max() const {
  // @@protoc_insertion_point(field_get:RobotLimits.acc_brake_angular_max)
  return acc_brake_angular_max_;
}
inline void RobotLimits::set_acc_brake_angular_max(float value) {
  set_has_acc_brake_angular_max();
  acc_brake_angular_max_ = value;
  // @@protoc_insertion_point(field_set:RobotLimits.acc_brake_angular_max)
}

// optional float vel_absolute_max = 5;
inline bool RobotLimits::has_vel_absolute_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotLimits::set_has_vel_absolute_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotLimits::clear_has_vel_absolute_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotLimits::clear_vel_absolute_max() {
  vel_absolute_max_ = 0;
  clear_has_vel_absolute_max();
}
inline float RobotLimits::vel_absolute_max() const {
  // @@protoc_insertion_point(field_get:RobotLimits.vel_absolute_max)
  return vel_absolute_max_;
}
inline void RobotLimits::set_vel_absolute_max(float value) {
  set_has_vel_absolute_max();
  vel_absolute_max_ = value;
  // @@protoc_insertion_point(field_set:RobotLimits.vel_absolute_max)
}

// optional float vel_angular_max = 6;
inline bool RobotLimits::has_vel_angular_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotLimits::set_has_vel_angular_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotLimits::clear_has_vel_angular_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotLimits::clear_vel_angular_max() {
  vel_angular_max_ = 0;
  clear_has_vel_angular_max();
}
inline float RobotLimits::vel_angular_max() const {
  // @@protoc_insertion_point(field_get:RobotLimits.vel_angular_max)
  return vel_angular_max_;
}
inline void RobotLimits::set_vel_angular_max(float value) {
  set_has_vel_angular_max();
  vel_angular_max_ = value;
  // @@protoc_insertion_point(field_set:RobotLimits.vel_angular_max)
}

// -------------------------------------------------------------------

// RobotWheelAngles

// required float front_right = 1;
inline bool RobotWheelAngles::has_front_right() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotWheelAngles::set_has_front_right() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotWheelAngles::clear_has_front_right() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotWheelAngles::clear_front_right() {
  front_right_ = 0;
  clear_has_front_right();
}
inline float RobotWheelAngles::front_right() const {
  // @@protoc_insertion_point(field_get:RobotWheelAngles.front_right)
  return front_right_;
}
inline void RobotWheelAngles::set_front_right(float value) {
  set_has_front_right();
  front_right_ = value;
  // @@protoc_insertion_point(field_set:RobotWheelAngles.front_right)
}

// required float back_right = 2;
inline bool RobotWheelAngles::has_back_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotWheelAngles::set_has_back_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotWheelAngles::clear_has_back_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotWheelAngles::clear_back_right() {
  back_right_ = 0;
  clear_has_back_right();
}
inline float RobotWheelAngles::back_right() const {
  // @@protoc_insertion_point(field_get:RobotWheelAngles.back_right)
  return back_right_;
}
inline void RobotWheelAngles::set_back_right(float value) {
  set_has_back_right();
  back_right_ = value;
  // @@protoc_insertion_point(field_set:RobotWheelAngles.back_right)
}

// required float back_left = 3;
inline bool RobotWheelAngles::has_back_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotWheelAngles::set_has_back_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotWheelAngles::clear_has_back_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotWheelAngles::clear_back_left() {
  back_left_ = 0;
  clear_has_back_left();
}
inline float RobotWheelAngles::back_left() const {
  // @@protoc_insertion_point(field_get:RobotWheelAngles.back_left)
  return back_left_;
}
inline void RobotWheelAngles::set_back_left(float value) {
  set_has_back_left();
  back_left_ = value;
  // @@protoc_insertion_point(field_set:RobotWheelAngles.back_left)
}

// required float front_left = 4;
inline bool RobotWheelAngles::has_front_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotWheelAngles::set_has_front_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotWheelAngles::clear_has_front_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotWheelAngles::clear_front_left() {
  front_left_ = 0;
  clear_has_front_left();
}
inline float RobotWheelAngles::front_left() const {
  // @@protoc_insertion_point(field_get:RobotWheelAngles.front_left)
  return front_left_;
}
inline void RobotWheelAngles::set_front_left(float value) {
  set_has_front_left();
  front_left_ = value;
  // @@protoc_insertion_point(field_set:RobotWheelAngles.front_left)
}

// -------------------------------------------------------------------

// RobotSpecs

// required .RobotId id = 1;
inline bool RobotSpecs::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotSpecs::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotSpecs::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::RobotId& RobotSpecs::_internal_id() const {
  return *id_;
}
inline const ::RobotId& RobotSpecs::id() const {
  const ::RobotId* p = id_;
  // @@protoc_insertion_point(field_get:RobotSpecs.id)
  return p != NULL ? *p : *reinterpret_cast<const ::RobotId*>(
      &::_RobotId_default_instance_);
}
inline ::RobotId* RobotSpecs::release_id() {
  // @@protoc_insertion_point(field_release:RobotSpecs.id)
  clear_has_id();
  ::RobotId* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::RobotId* RobotSpecs::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::RobotId>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RobotSpecs.id)
  return id_;
}
inline void RobotSpecs::set_allocated_id(::RobotId* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    set_has_id();
  } else {
    clear_has_id();
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:RobotSpecs.id)
}

// optional float radius = 2 [default = 0.09];
inline bool RobotSpecs::has_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RobotSpecs::set_has_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RobotSpecs::clear_has_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RobotSpecs::clear_radius() {
  radius_ = 0.09f;
  clear_has_radius();
}
inline float RobotSpecs::radius() const {
  // @@protoc_insertion_point(field_get:RobotSpecs.radius)
  return radius_;
}
inline void RobotSpecs::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:RobotSpecs.radius)
}

// optional float height = 3 [default = 0.15];
inline bool RobotSpecs::has_height() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RobotSpecs::set_has_height() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RobotSpecs::clear_has_height() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RobotSpecs::clear_height() {
  height_ = 0.15f;
  clear_has_height();
}
inline float RobotSpecs::height() const {
  // @@protoc_insertion_point(field_get:RobotSpecs.height)
  return height_;
}
inline void RobotSpecs::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:RobotSpecs.height)
}

// optional float mass = 4;
inline bool RobotSpecs::has_mass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotSpecs::set_has_mass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotSpecs::clear_has_mass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotSpecs::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float RobotSpecs::mass() const {
  // @@protoc_insertion_point(field_get:RobotSpecs.mass)
  return mass_;
}
inline void RobotSpecs::set_mass(float value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:RobotSpecs.mass)
}

// optional float max_linear_kick_speed = 7;
inline bool RobotSpecs::has_max_linear_kick_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotSpecs::set_has_max_linear_kick_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotSpecs::clear_has_max_linear_kick_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotSpecs::clear_max_linear_kick_speed() {
  max_linear_kick_speed_ = 0;
  clear_has_max_linear_kick_speed();
}
inline float RobotSpecs::max_linear_kick_speed() const {
  // @@protoc_insertion_point(field_get:RobotSpecs.max_linear_kick_speed)
  return max_linear_kick_speed_;
}
inline void RobotSpecs::set_max_linear_kick_speed(float value) {
  set_has_max_linear_kick_speed();
  max_linear_kick_speed_ = value;
  // @@protoc_insertion_point(field_set:RobotSpecs.max_linear_kick_speed)
}

// optional float max_chip_kick_speed = 8;
inline bool RobotSpecs::has_max_chip_kick_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotSpecs::set_has_max_chip_kick_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotSpecs::clear_has_max_chip_kick_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotSpecs::clear_max_chip_kick_speed() {
  max_chip_kick_speed_ = 0;
  clear_has_max_chip_kick_speed();
}
inline float RobotSpecs::max_chip_kick_speed() const {
  // @@protoc_insertion_point(field_get:RobotSpecs.max_chip_kick_speed)
  return max_chip_kick_speed_;
}
inline void RobotSpecs::set_max_chip_kick_speed(float value) {
  set_has_max_chip_kick_speed();
  max_chip_kick_speed_ = value;
  // @@protoc_insertion_point(field_set:RobotSpecs.max_chip_kick_speed)
}

// optional float center_to_dribbler = 9;
inline bool RobotSpecs::has_center_to_dribbler() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RobotSpecs::set_has_center_to_dribbler() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RobotSpecs::clear_has_center_to_dribbler() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RobotSpecs::clear_center_to_dribbler() {
  center_to_dribbler_ = 0;
  clear_has_center_to_dribbler();
}
inline float RobotSpecs::center_to_dribbler() const {
  // @@protoc_insertion_point(field_get:RobotSpecs.center_to_dribbler)
  return center_to_dribbler_;
}
inline void RobotSpecs::set_center_to_dribbler(float value) {
  set_has_center_to_dribbler();
  center_to_dribbler_ = value;
  // @@protoc_insertion_point(field_set:RobotSpecs.center_to_dribbler)
}

// optional .RobotLimits limits = 10;
inline bool RobotSpecs::has_limits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotSpecs::set_has_limits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotSpecs::clear_has_limits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotSpecs::clear_limits() {
  if (limits_ != NULL) limits_->Clear();
  clear_has_limits();
}
inline const ::RobotLimits& RobotSpecs::_internal_limits() const {
  return *limits_;
}
inline const ::RobotLimits& RobotSpecs::limits() const {
  const ::RobotLimits* p = limits_;
  // @@protoc_insertion_point(field_get:RobotSpecs.limits)
  return p != NULL ? *p : *reinterpret_cast<const ::RobotLimits*>(
      &::_RobotLimits_default_instance_);
}
inline ::RobotLimits* RobotSpecs::release_limits() {
  // @@protoc_insertion_point(field_release:RobotSpecs.limits)
  clear_has_limits();
  ::RobotLimits* temp = limits_;
  limits_ = NULL;
  return temp;
}
inline ::RobotLimits* RobotSpecs::mutable_limits() {
  set_has_limits();
  if (limits_ == NULL) {
    auto* p = CreateMaybeMessage<::RobotLimits>(GetArenaNoVirtual());
    limits_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RobotSpecs.limits)
  return limits_;
}
inline void RobotSpecs::set_allocated_limits(::RobotLimits* limits) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limits_;
  }
  if (limits) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limits = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limits, submessage_arena);
    }
    set_has_limits();
  } else {
    clear_has_limits();
  }
  limits_ = limits;
  // @@protoc_insertion_point(field_set_allocated:RobotSpecs.limits)
}

// optional .RobotWheelAngles wheel_angles = 13;
inline bool RobotSpecs::has_wheel_angles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotSpecs::set_has_wheel_angles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotSpecs::clear_has_wheel_angles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotSpecs::clear_wheel_angles() {
  if (wheel_angles_ != NULL) wheel_angles_->Clear();
  clear_has_wheel_angles();
}
inline const ::RobotWheelAngles& RobotSpecs::_internal_wheel_angles() const {
  return *wheel_angles_;
}
inline const ::RobotWheelAngles& RobotSpecs::wheel_angles() const {
  const ::RobotWheelAngles* p = wheel_angles_;
  // @@protoc_insertion_point(field_get:RobotSpecs.wheel_angles)
  return p != NULL ? *p : *reinterpret_cast<const ::RobotWheelAngles*>(
      &::_RobotWheelAngles_default_instance_);
}
inline ::RobotWheelAngles* RobotSpecs::release_wheel_angles() {
  // @@protoc_insertion_point(field_release:RobotSpecs.wheel_angles)
  clear_has_wheel_angles();
  ::RobotWheelAngles* temp = wheel_angles_;
  wheel_angles_ = NULL;
  return temp;
}
inline ::RobotWheelAngles* RobotSpecs::mutable_wheel_angles() {
  set_has_wheel_angles();
  if (wheel_angles_ == NULL) {
    auto* p = CreateMaybeMessage<::RobotWheelAngles>(GetArenaNoVirtual());
    wheel_angles_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RobotSpecs.wheel_angles)
  return wheel_angles_;
}
inline void RobotSpecs::set_allocated_wheel_angles(::RobotWheelAngles* wheel_angles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wheel_angles_;
  }
  if (wheel_angles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wheel_angles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wheel_angles, submessage_arena);
    }
    set_has_wheel_angles();
  } else {
    clear_has_wheel_angles();
  }
  wheel_angles_ = wheel_angles;
  // @@protoc_insertion_point(field_set_allocated:RobotSpecs.wheel_angles)
}

// repeated .google.protobuf.Any custom = 14;
inline int RobotSpecs::custom_size() const {
  return custom_.size();
}
inline ::google::protobuf::Any* RobotSpecs::mutable_custom(int index) {
  // @@protoc_insertion_point(field_mutable:RobotSpecs.custom)
  return custom_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
RobotSpecs::mutable_custom() {
  // @@protoc_insertion_point(field_mutable_list:RobotSpecs.custom)
  return &custom_;
}
inline const ::google::protobuf::Any& RobotSpecs::custom(int index) const {
  // @@protoc_insertion_point(field_get:RobotSpecs.custom)
  return custom_.Get(index);
}
inline ::google::protobuf::Any* RobotSpecs::add_custom() {
  // @@protoc_insertion_point(field_add:RobotSpecs.custom)
  return custom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
RobotSpecs::custom() const {
  // @@protoc_insertion_point(field_list:RobotSpecs.custom)
  return custom_;
}

// -------------------------------------------------------------------

// RealismConfig

// repeated .google.protobuf.Any custom = 1;
inline int RealismConfig::custom_size() const {
  return custom_.size();
}
inline ::google::protobuf::Any* RealismConfig::mutable_custom(int index) {
  // @@protoc_insertion_point(field_mutable:RealismConfig.custom)
  return custom_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
RealismConfig::mutable_custom() {
  // @@protoc_insertion_point(field_mutable_list:RealismConfig.custom)
  return &custom_;
}
inline const ::google::protobuf::Any& RealismConfig::custom(int index) const {
  // @@protoc_insertion_point(field_get:RealismConfig.custom)
  return custom_.Get(index);
}
inline ::google::protobuf::Any* RealismConfig::add_custom() {
  // @@protoc_insertion_point(field_add:RealismConfig.custom)
  return custom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
RealismConfig::custom() const {
  // @@protoc_insertion_point(field_list:RealismConfig.custom)
  return custom_;
}

// -------------------------------------------------------------------

// SimulatorConfig

// optional .SSL_GeometryData geometry = 1;
inline bool SimulatorConfig::has_geometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimulatorConfig::set_has_geometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimulatorConfig::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SSL_GeometryData& SimulatorConfig::_internal_geometry() const {
  return *geometry_;
}
inline const ::SSL_GeometryData& SimulatorConfig::geometry() const {
  const ::SSL_GeometryData* p = geometry_;
  // @@protoc_insertion_point(field_get:SimulatorConfig.geometry)
  return p != NULL ? *p : *reinterpret_cast<const ::SSL_GeometryData*>(
      &::_SSL_GeometryData_default_instance_);
}
inline ::SSL_GeometryData* SimulatorConfig::release_geometry() {
  // @@protoc_insertion_point(field_release:SimulatorConfig.geometry)
  clear_has_geometry();
  ::SSL_GeometryData* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline ::SSL_GeometryData* SimulatorConfig::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) {
    auto* p = CreateMaybeMessage<::SSL_GeometryData>(GetArenaNoVirtual());
    geometry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SimulatorConfig.geometry)
  return geometry_;
}
inline void SimulatorConfig::set_allocated_geometry(::SSL_GeometryData* geometry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(geometry_);
  }
  if (geometry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geometry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:SimulatorConfig.geometry)
}

// repeated .RobotSpecs robot_specs = 2;
inline int SimulatorConfig::robot_specs_size() const {
  return robot_specs_.size();
}
inline void SimulatorConfig::clear_robot_specs() {
  robot_specs_.Clear();
}
inline ::RobotSpecs* SimulatorConfig::mutable_robot_specs(int index) {
  // @@protoc_insertion_point(field_mutable:SimulatorConfig.robot_specs)
  return robot_specs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::RobotSpecs >*
SimulatorConfig::mutable_robot_specs() {
  // @@protoc_insertion_point(field_mutable_list:SimulatorConfig.robot_specs)
  return &robot_specs_;
}
inline const ::RobotSpecs& SimulatorConfig::robot_specs(int index) const {
  // @@protoc_insertion_point(field_get:SimulatorConfig.robot_specs)
  return robot_specs_.Get(index);
}
inline ::RobotSpecs* SimulatorConfig::add_robot_specs() {
  // @@protoc_insertion_point(field_add:SimulatorConfig.robot_specs)
  return robot_specs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RobotSpecs >&
SimulatorConfig::robot_specs() const {
  // @@protoc_insertion_point(field_list:SimulatorConfig.robot_specs)
  return robot_specs_;
}

// optional .RealismConfig realism_config = 3;
inline bool SimulatorConfig::has_realism_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimulatorConfig::set_has_realism_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimulatorConfig::clear_has_realism_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimulatorConfig::clear_realism_config() {
  if (realism_config_ != NULL) realism_config_->Clear();
  clear_has_realism_config();
}
inline const ::RealismConfig& SimulatorConfig::_internal_realism_config() const {
  return *realism_config_;
}
inline const ::RealismConfig& SimulatorConfig::realism_config() const {
  const ::RealismConfig* p = realism_config_;
  // @@protoc_insertion_point(field_get:SimulatorConfig.realism_config)
  return p != NULL ? *p : *reinterpret_cast<const ::RealismConfig*>(
      &::_RealismConfig_default_instance_);
}
inline ::RealismConfig* SimulatorConfig::release_realism_config() {
  // @@protoc_insertion_point(field_release:SimulatorConfig.realism_config)
  clear_has_realism_config();
  ::RealismConfig* temp = realism_config_;
  realism_config_ = NULL;
  return temp;
}
inline ::RealismConfig* SimulatorConfig::mutable_realism_config() {
  set_has_realism_config();
  if (realism_config_ == NULL) {
    auto* p = CreateMaybeMessage<::RealismConfig>(GetArenaNoVirtual());
    realism_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SimulatorConfig.realism_config)
  return realism_config_;
}
inline void SimulatorConfig::set_allocated_realism_config(::RealismConfig* realism_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete realism_config_;
  }
  if (realism_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      realism_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, realism_config, submessage_arena);
    }
    set_has_realism_config();
  } else {
    clear_has_realism_config();
  }
  realism_config_ = realism_config;
  // @@protoc_insertion_point(field_set_allocated:SimulatorConfig.realism_config)
}

// optional uint32 vision_port = 4;
inline bool SimulatorConfig::has_vision_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimulatorConfig::set_has_vision_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimulatorConfig::clear_has_vision_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimulatorConfig::clear_vision_port() {
  vision_port_ = 0u;
  clear_has_vision_port();
}
inline ::google::protobuf::uint32 SimulatorConfig::vision_port() const {
  // @@protoc_insertion_point(field_get:SimulatorConfig.vision_port)
  return vision_port_;
}
inline void SimulatorConfig::set_vision_port(::google::protobuf::uint32 value) {
  set_has_vision_port();
  vision_port_ = value;
  // @@protoc_insertion_point(field_set:SimulatorConfig.vision_port)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_ssl_5fsimulation_5fconfig_2eproto
